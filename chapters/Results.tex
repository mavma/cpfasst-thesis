% !TEX root = ../main.tex
\chapter{Results and analysis}
\label{chapter:results}

\section{The cpfasst interface}

All example code shown in this work, along with suitable build configurations, is hosted in a GitHub repository\footnote{\url{https://github.com/mavma/mlp_examples}}, as is the resulting library code for cpfasst\footnote{\url{https://github.com/mavma/cpfasst}}. Two examples of the use of LibPFASST entirely from C code through the interface are provided by cpfasst. They reproduce the Fortran tutorials of the same name distributed with LibPFASST \cite{libpfasst_ug}:
\begin{itemize}
	\item \textbf{EX2\_Dahlquist} solves the 1D Dahlquist test problem \(y' = \lambda y,\,y(0) = 1\), with an implicit-explicit split \(y' = \lambda_1 y + \lambda_2 y\), where the first term is treated explicitly and the second implicitly, and no grid coarsening in space;
	\item \textbf{EX3\_adv\_diff} solves the 1D linear advection diffusion equation \(u_t = -v u_x + \nu u_{xx}\), with a pseudo-spectral discretization in space and the method of lines in time. In this case, the Fortran tutorial utilizes LibPFASST-provided component \ilc{pf_fft_t}, a fast Fourier transform tool based on fftpack\footnote{\url{https://www.netlib.org/fftpack/}}. Instead of interfacing with the same component, the C example utilizes the C version of fftpack to implement the same functionality: this is intended to demonstrate that code utilizing cpfasst can integrate other C tools as needed.
\end{itemize}

The examples do not only to demonstrate the use of cpfasst, but also are an important part of verification: test scripts are provided to run each of the cpfasst examples and the corresponding LibPFASST tutorial, and compare their outputs. Hence it is important the cpfasst examples reproduce the behavior of their counterparts as faithfully as possible. To support this, the interface code for cpfasst includes not only the major components described in \refChapter{chapter:implementation}, but also get/set interfaces for a handful of additional data components in the main LibPFASST structure.

Each of the LibPFASST tutorials includes a set of nml files containing parameter values for different test cases. These are used in Fortran not only to provide LibPFASST configurations as described in \refSection{sec:impl_pfasst_config}, but also to initialize problem-specific configuration. To facilitate the reproduction of these test cases for the C examples, the interface allows initialization of LibPFASST parameters through nml files, as shown in \refSection{sec:impl_pfasst_config}. Additionally, each C example implements a simplified nml parser, used to read problem-specific parameter values from the LibPFASST-provided configurations --- the user is encouraged to replace this with a C-friendly input format.

Continuous integration runs are set up to compare outputs for each of the examples and tutorials, using each LibPFASST-provided configuration, in sequential and parallel. Output files containing the values of the residual, error and change in initial condition for each sweep executed are compared, and the test is considered successful if the outputs are an exact match. At the LibPFASST output precision of 14 significant digits, all the tests succeed: cpfasst examples match their LibPFASST equivalents exactly. Based on these results, as well as verification of the interface through the methods described in \refSection{sec:impl_verification}, we conclude that cpfasst is suitable for future use in C projects. 

\section{Lessons learned}

The original intent with this development was to quickly implement the C/Fortran interface, and then move on to integration with existing C code or the construction of a Python interface: the expectation was that interfacing with C would be, as described in the LibPFASST's description, \textit{fairly easy}. This is not an unreasonable expectation when it comes to interfacing Fortran and C in general: a good understanding of the Fortran 2003 interoperability features trivializes the creation of C interface for a Fortran library consisting entirely of procedures with sufficiently simple interfaces (no arguments of derived non-interoperable types) which the C user wants to call. Designing the interoperable interface in this case does not require knowledge of how a procedure works, only of what its inputs and outputs should be. Note that a simple interface does not imply trivial library functionality: both LAPACK and BLAS fit this criterion.

LibPFASST, however, presents two major challenges to interoperability:
\begin{enumerate}
	\item \label{problem_oop} \textbf{Object-oriented code} creates an inherent challenge for interfacing with a purely procedural language. This is aggravated by the way LibPFASST use was designed: the user does not use LibPFASST types as much as they provide their own types for LibPFASST to use, which must be created through inheritance, a non-interoperable mechanism.
	\item \label{problem_nested_types} \textbf{Nested non-interoperable types}, which frequently appear as arguments in LibPFASST procedures, cannot be forwarded directly to C calls. Creation of interoperable interfaces for those procedures requires breaking these types down into interoperable components of interest to the user, or omitting them entirely --- which, in turn, requires knowledge of how LibPFASST is implemented and what its potential use cases are.
\end{enumerate}

For both issues, there is no direct solution aside from extensive refactoring of LibPFASST or a change to the Fortran standard --- so instead, we provide paths to work around them. In the case of \ref{problem_oop}, the patterns in Sections \ref{sec:impl_functions} and \ref{sec:impl_data} allow for a sufficiently close approximation of a child class by a combination of cpfasst Fortran code and the user's C code, albeit with some limitations, as discussed in \refSection{sec:impl_restrictions}. When it comes to \ref{problem_nested_types}, no pattern was identified for that can cover all cases: a workaround must be found for each individual procedure depending on its purpose and the types involved. However, the examples discussed in Sections \ref{sec:impl_calls} and \ref{sec:impl_initializing} illustrate successful approaches in different scenarios.

As a consequence of these challenges, design of the C interface became the project itself. Thus, we consider the architecture of the interoperable interface as much a result as the cpfasst code. While cpfasst only provides interfaces for a subset of LibPFASST components, use of the patterns presented in \refSection{sec:impl_oop} and the verification techniques shown in \refSection{sec:impl_verification} will hopefully provide a much smoother path to future work extending the interface to other LibPFASST components.

From the interface design detailed in \refChapter{chapter:implementation}, we synthesize the following guidelines for design of an interoperable interface in Fortran:
\begin{enumerate}
  	\setcounter{enumi}{-1}
	\item \textbf{Use standard interoperability in all interfaces.} Every Fortran procedure called from C, and Fortran interface describing a C function \textit{must} include the \ilc{bind(C)} attribute. As a consequence, the types of all arguments and returns of these procedures must either a \ilc{kind} parameter from the \ilc{iso_c_binding} module, or, for derived types, contain the \ilc{bind(C)} attribute, as described in \refSection{sec:interop_f03}. It can be tempting to ignore this when a non-interoperable component prevents the use of \ilc{bind(C)} and the interface appears to function correctly without it --- however, such an interface relies on compiler-specific or undefined behavior, and can hide a number of issues, detailed in \refSection{sec:interop_f90}. If the compiler disallows (or warns about) usage of a type with \ilc{bind(C)}, it must either be replaced by an equivalent interoperable type, or omitted from the interoperable interface entirely.
	\item \textbf{Employ data encapsulation between languages.} Just as in object-oriented code, allowing access to all data from all contexts may be convenient, but in practice creates an unintuitive and hard to verify interface. It can be useful to see different languages as different object-oriented classes, with a shared understanding of some (interoperable) types, but not others: interoperable types with different conventions in each language (see \refSection{sec:interop_f03}), such as multidimensional arrays (row-major vs column-major) and strings (null-terminated vs blank padded) can be accessed in a manner that is correct when it comes to the underlying data type, but incorrect when it comes to how it is interpreted. Sharing data between languages is best done, as between object-oriented classes, through procedure arguments clearly identified as inputs and outputs, and get/set interfaces which convert between the appropriate conventions as needed. In the specific case of numerical applications, the memory and performance overhead associated with repeated conversion of large multidimensional arrays between row-major and column-major can make this approach non-viable --- in this case, if possible, access to array data should be restricted to a single language, with the other using opaque references if needed: this the approach used by cpfasst, as detailed in Sections \ref{sec:impl_data} and \ref{sec:impl_calls}.
	\item \textbf{Test for interoperability-specific issues during verification.} \refSection{sec:impl_verification} details two types of issues that are of particular interest to an interoperable application: mismatched representation of entities between languages, and out-of-bounds memory accesses in stack and global memory, and discusses tools that can be used to identify them. Here we recommend, in particular, the use of GCC's AddressSanitizer (\ilc{-fsanitize=address}) and link-time optimization features (\ilc{-flto}). Additionally, it is important to adjust expectations about the potential causes of some errors when compared to single-language environments: as a bug in the interface or its use can violate the compiler's assumptions about the application environment, we found that attempting to diagnose an issue such as a segmentation fault with the same approach used for a C-only application will often attribute it to an entirely unrelated area of code, as mentioned in \refSection{sec:impl_verification}.	
\end{enumerate}

Additionally, we recommend the following to designers of new Fortran libraries intended for interoperable use:
\begin{enumerate}
	\item \textbf{Design interfaces that are procedural and interoperable.} All external interfaces should be (non type-bound) procedure calls with the \ilc{bind(C)} attribute. Note that this restricts the use of object-oriented features in the arguments and returns, not in the implementation itself. If it is desirable to offer object-oriented interfaces to Fortran users, this should be done through reuse of the procedural interoperable interfaces --- it is far easier to create object-oriented wrappers for procedural calls than the other way around.
	\item \textbf{If interfaces must be object-oriented, employ delegation.} If association of C function calls with deferred type-bound procedures cannot be avoided, the patterns shown in \refSection{sec:impl_oop} can be employed to build a callback interface. This is greatly facilitated by creation of a type containing only these type-bound procedures (also known in other object-oriented languages as a \textit{pure abstract} or \textit{interface} class). This type can then be used by Fortran code through \textit{delegation}. Additionally, the type-bound procedures should have interoperable argument and return types (excluding the first argument, a reference to the owner object, which in this scenario can never be interoperable). This avoids any concerns about access to parent data (see \refSection{sec:impl_data}), which procedures from the parent type to override (see \refSection{sec:impl_restrictions}) and forwarding non-interoperable arguments (see \refSection{sec:impl_calls}).
\end{enumerate}